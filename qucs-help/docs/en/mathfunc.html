<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name="Author" content="Michael Margraf">
<title>Qucs - Math Functions</title>
</head>



<body>
<a name="top" id="top"></a>

<center><h3>
- Qucs -<br>
Quite Universal Circuit Simulator<br>
</h3>
<h1>
Short Description of mathematical Functions<br><br>
</h1></center>

The following operations and functions can be applied in
Qucs equations.<br><br>

<table cellspacing=2 cellpadding=2>
<tr><td><tt>+x</tt></td><td>unary plus</td></tr>
<tr><td><tt>-x</tt></td><td>unary minus</td></tr>
<tr><td><tt>x+y</tt></td><td>addition</td></tr>
<tr><td><tt>x-y</tt></td><td>subtraction</td></tr>
<tr><td><tt>x*y</tt></td><td>multiplication</td></tr>
<tr><td><tt>x/y</tt></td><td>division</td></tr>
<tr><td><tt>x%y</tt></td><td>modulo (remainder of division)</td></tr>
<tr><td><tt>x^y</tt></td><td>power</td></tr>
<tr><td><tt>max(x[,range])</tt></td><td>maximum value in vector; if a <tt>range</tt> is given then <tt>x</tt> must have a single data dependency</td></tr>
<tr><td><tt>min(x[,range])</tt></td><td>minimum value in vector; if a <tt>range</tt> is given then <tt>x</tt> must have a single data dependency</td></tr>
<tr><td><tt>avg(x[,range])</tt></td><td>arithmetic average of values in vector; if a <tt>range</tt> is given then <tt>x</tt> must have a single data dependency</td></tr>
<tr><td><tt>cumavg(x)</tt></td><td>cumulative average of values in vector</td></tr>
<tr><td><tt>runavg(x)</tt></td><td>running average of values in vector</td></tr>
<tr><td><tt>stddev(x)</tt></td><td>standard deviation of values in vector</td></tr>
<tr><td><tt>variance(x)</tt></td><td>variance of values in vector</td></tr>

<tr><td><tt>sum(x)</tt></td><td>sum of values in vector</td></tr>
<tr><td><tt>prod(x)</tt></td><td>product of values in vector</td></tr>
<tr><td><tt>cumsum(x)</tt></td><td>cumulative sum of values in vector</td></tr>
<tr><td><tt>cumprod(x)</tt></td><td>cumulative product of values in vector</td></tr>
<tr><td><tt>diff(y,x)</tt></td>
<td>differentiates vector y with respect to x</td></tr>
<tr><td><tt>diff(y,x,n)</tt></td>
<td>differentiates vector y with respect to x n-times</td></tr>
<tr><td><tt>real(x)</tt></td><td>real part of complex number</td></tr>
<tr><td><tt>imag(x)</tt></td><td>imaginary part of complex number</td></tr>
<tr><td><tt>abs(x)</tt></td><td>absolute value, magnitude of complex number</td></tr>
<tr><td><tt>mag(x)</tt></td><td>same as abs(x)</td></tr>
<tr><td><tt>norm(x)</tt></td><td>square of mag(x)</td></tr>
<tr><td><tt>conj(x)</tt></td><td>conjugate complex</td></tr>
<tr><td><tt>phase(x)</tt></td><td>phase in degree</td></tr>
<tr><td><tt>angle(x)</tt></td><td>phase in radians</td></tr>
<tr><td><tt>arg(x)</tt></td><td>same as angle(x)</td></tr>
<tr><td><tt>deg2rad(x)</tt></td><td>converts degrees to radians</td></tr>
<tr><td><tt>rad2deg(x)</tt></td><td>converts radians to degrees</td></tr>
<tr><td><tt>unwrap(rad[,tol])</tt></td><td>unwraps the angle (in radians) using the optional tolerance value (default is pi)</td></tr>
<tr><td><tt>dB(x)</tt></td><td>voltage decibel</td></tr>
<tr><td><tt>dbm(x)</tt></td><td>convert voltage to power in dB</td></tr>
<tr><td><tt>dbm2w(x)</tt></td><td>convert power in dBm to power in Watts</td></tr>
<tr><td><tt>w2dbm(x)</tt></td><td>convert power in Watts to power in dBm</td></tr>

<tr><td><tt>sqr(x)</tt></td><td>square (x to the power of two)</td></tr>
<tr><td><tt>sqrt(x)</tt></td><td>square root</td></tr>
<tr><td><tt>exp(x)</tt></td><td>exponential function to basis e</td></tr>
<tr><td><tt>ln(x)</tt></td><td>natural logarithm</td></tr>
<tr><td><tt>log10(x)</tt></td><td>decimal logarithm</td></tr>
<tr><td><tt>log2(x)</tt></td><td>binary logarithm</td></tr>
<tr><td><tt>sin(x)</tt></td><td>sine</td></tr>
<tr><td><tt>cos(x)</tt></td><td>cosine</td></tr>
<tr><td><tt>tan(x)</tt></td><td>tangent</td></tr>
<tr><td><tt>sinh(x)</tt></td><td>sine hyperbolicus</td></tr>
<tr><td><tt>cosh(x)</tt></td><td>cosine hyperbolicus</td></tr>
<tr><td><tt>tanh(x)</tt></td><td>tangent hyperbolicus</td></tr>
<tr><td><tt>arcsin(x)</tt></td><td>arcus sine</td></tr>
<tr><td><tt>arccos(x)</tt></td><td>arcus cosine</td></tr>
<tr><td><tt>arctan(x)</tt></td><td>arcus tangent</td></tr>
<tr><td><tt>arccot(x)</tt></td><td>arcus cotangent</td></tr>
<tr><td><tt>arsinh(x)</tt></td><td>area sine hyperbolicus</td></tr>
<tr><td><tt>arcosh(x)</tt></td><td>area cosine hyperbolicus</td></tr>
<tr><td><tt>artanh(x)</tt></td><td>area tangent hyperbolicus</td></tr>
<tr><td><tt>arcoth(x)</tt></td><td>area cotangent hyperbolicus</td></tr>
<tr><td><tt>sec(x)</tt></td><td>secans</td></tr>
<tr><td><tt>cosec(x)</tt></td><td>cosecans</td></tr>
<tr><td><tt>cot(x)</tt></td><td>cotangent</td></tr>
<tr><td><tt>sech(x)</tt></td><td>secans hyperbolicus</td></tr>
<tr><td><tt>cosech(x)</tt></td><td>cosecans hyperbolicus</td></tr>
<tr><td><tt>coth(x)</tt></td><td>cotangent hyperbolicus</td></tr>

<tr><td><tt>ztor(x[,zref])</tt></td>
<td>converts impedance to reflexion coefficient (by default reference is 50 ohms)</td></tr>
<tr><td><tt>rtoz(x[,zref])</tt></td>
<td>converts reflexion coefficient (by default reference is 50 ohms) to impedance</td></tr>
<tr><td><tt>ytor(x[,zref])</tt></td>
<td>converts admittance to reflexion coefficient (by default reference is 50 ohms)</td></tr>
<tr><td><tt>rtoy(x[,zref])</tt></td>
<td>converts reflexion coefficient (by default reference is 50 ohms) to admittance</td></tr>
<tr><td><tt>rtoswr(x)</tt></td>
<td>converts reflexion coefficient to (voltage) standing wave ratio
(SWR or VSWR)</td></tr>
<tr><td><tt>stos(s,zref[,z0])</tt></td>
<td>converts s-parameter matrix to s-parameter matrix with different reference impedance(s)</td></tr>
<tr><td><tt>stoy(s[,zref])</tt></td>
<td>converts s-parameter matrix to y-parameter matrix</td></tr>
<tr><td><tt>stoz(s[,zref])</tt></td>
<td>converts s-parameter matrix to z-parameter matrix</td></tr>
<tr><td><tt>ytos(y[,z0])</tt></td>
<td>converts y-parameter matrix to s-parameter matrix</td></tr>
<tr><td><tt>ytoz(y)</tt></td>
<td>converts y-parameter matrix to z-parameter matrix</td></tr>
<tr><td><tt>ztos(z[,z0])</tt></td>
<td>converts z-parameter matrix to s-parameter matrix</td></tr>
<tr><td><tt>ztoy(z)</tt></td>
<td>converts z-parameter matrix to y-parameter matrix</td></tr>
<tr><td><tt>twoport(m,from,to)</tt></td>
<td>converts the given 2-port matrix from one representation into another,
possible values for <tt>"from"</tt> and <tt>"to"</tt> are 'Y', 'Z', 'H', 'G',
'A', 'S' and 'T'.</td></tr>

<tr><td><tt>ceil(x)</tt></td><td>rounds to the next higher integer</td></tr>
<tr><td><tt>fix(x)</tt></td><td>truncates decimal places from real number</td></tr>
<tr><td><tt>floor(x)</tt></td><td>rounds to the next lower integer</td></tr>
<tr><td><tt>round(x)</tt></td><td>rounds to nearest integer</td></tr>

<tr><td><tt>sign(x)</tt></td><td>computes the signum function</td></tr>
<tr><td><tt>sinc(x)</tt></td><td>returns sin(x)/x and one at x=0</td></tr>
<tr><td><tt>step(x)</tt></td><td>step function</td></tr>
<tr><td><tt>besseli0(x)</tt></td><td>modified Bessel function of order zero</td></tr>
<tr><td><tt>besselj(n,x)</tt></td><td>Bessel function of n-th order</td></tr>
<tr><td><tt>erf(x)</tt></td><td>error function</td></tr>
<tr><td><tt>erfc(x)</tt></td><td>complementary error function</td></tr>
<tr><td><tt>erfinv(x)</tt></td><td>inverse error function</td></tr>
<tr><td><tt>erfcinv(x)</tt></td><td>inverse complementary error function</td></tr>

<tr><td><tt>det(x)</tt></td><td>determinant of x</td></tr>
<tr><td><tt>transpose(x)</tt></td><td>transposed matrix of x (rows and columns exchanged)</td></tr>
<tr><td><tt>inverse(x)</tt></td><td>inverse matrix of x</td></tr>
<tr><td><tt>eye(n)</tt></td><td>n x n identity matrix</td></tr>
<tr><td><tt>adjoint(x)</tt></td><td>adjoint matrix of x (transposed and conjugate complex)</td></tr>
<tr><td><tt>Rollet(x)</tt></td><td>Rollet stability factor of matrix x (twoport S-parameter matrix)</td></tr>
<tr><td><tt>Mu(x)</tt></td><td>Mu stability factor of matrix x (twoport S-parameter matrix)</td></tr>
<tr><td><tt>Mu2(x)</tt></td><td>Mu' stability factor of matrix x (twoport S-parameter matrix)</td></tr>
<tr><td><tt>linspace(from,to,n)</tt></td><td>creates a vector with <tt>n</tt> linearly spaced elements between <tt>from</tt> and <tt>to</tt>, both inclusively</td></tr>
<tr><td><tt>logspace(from,to,n)</tt></td><td>creates a vector with <tt>n</tt> logarithmically spaced elements between <tt>from</tt> and <tt>to</tt>, both inclusively</td></tr>
<tr><td><tt>NoiseCircle(Sopt,<br>&nbsp;&nbsp;Fmin,Rn,F[,Arcs])</tt></td><td>circles with constant noise figure(s) <tt>F</tt> (can be a constant or a vector), <tt>Arcs</tt> specifies the angles in degree created by e.g. <tt>linspace(0,360,100)</tt>, if <tt>Arcs</tt> is a number it specifies the number of equally spaced circle segments, if it is omitted this number defaults to a reasonable value</td></tr>
<tr><td><tt>StabCircleS(S [,Arcs])</tt></td><td>stability circle in the source plane</td></tr>
<tr><td><tt>StabCircleL(S [,Arcs])</tt></td><td>stability circle in the load plane</td></tr>
<tr><td><tt>GaCircle(S,Ga [,Arcs])</tt></td><td>circle(s) with constant available power gain <tt>Ga</tt> in the source plane</td></tr>
<tr><td><tt>GpCircle(S,Gp [,Arcs])</tt></td><td>circle(s) with constant operating power gain <tt>Gp</tt> in the load plane</td></tr>
<tr><td><tt>PlotVs(data,dep)</tt></td><td>returns a data item based upon <tt>data</tt> (vector or matrix vector) with dependency on the given <tt>dep</tt> vector, e.g. <tt>PlotVs(Gain,frequency/1e9)</tt></td></tr>
<tr><td><tt>interpolate(f,x[,n])</tt></td><td>returns an interpolated data vector of the real function <tt>f(x)</tt>using <tt>n</tt> equidistant datapoints, the latter can be omitted and defaults to a reasonable value</td></tr>
<tr><td><tt>fft(v,t)</tt></td><td>computes the fast fourier transformation (FFT) of the function <tt>v(t)</tt></td></tr>
<tr><td><tt>ifft(V,f)</tt></td><td>computes the inverse fast fourier transformation (IFFT) of the function <tt>V(f)</tt></td></tr>
<tr><td><tt>dft(v,t)</tt></td><td>computes the discrete fourier transformation (DFT) of the function <tt>v(t)</tt></td></tr>
<tr><td><tt>idft(V,f)</tt></td><td>computes the inverse discrete fourier transformation (IDFT) of the function <tt>V(f)</tt></td></tr>
<tr><td><tt>kbd(x [,n])</tt></td><td>Kaiser-Bessel derived window</td></tr>
<tr><td><tt>yvalue(f,xval)</tt></td><td>returns the y-value of the given vector <tt>f</tt> which is located nearest to the x-value <tt>xval</tt>; therefore the vector <tt>f</tt> must have a single data dependency</td></tr>
<tr><td><tt>xvalue(f,yval)</tt></td><td>returns the x-value which is associated  with the y-value nearest to <tt>yval</tt> in the given vector <tt>f</tt>; therefore the vector <tt>f</tt> must have a single data dependency</td></tr>

</table>
<br>

<b>Range nomenclature</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>LO:HI</tt></td><td>range from <tt>LO</tt> to <tt>HI</tt></td></tr>
<tr><td><tt>:HI</tt></td><td>up to <tt>HI</tt></td></tr>
<tr><td><tt>LO:</tt></td><td>from <tt>LO</tt></td></tr>
<tr><td><tt>:</tt></td><td>no range limitations</td></tr>
</table>
<br>

<b>Matrix nomenclature</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>M</tt></td><td>the whole matrix M</td></tr>
<tr><td><tt>M[2,3]</tt></td><td>element being in 2nd row and 3rd column of matrix M</td></tr>
<tr><td><tt>M[:,3]</tt></td><td>vector consisting of 3rd column of matrix M</td></tr>
</table>
<br>

<b>Name of values</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>S[1,1]</tt></td><td>S-parameter value</td></tr>
<tr><td><i>nodename</i><tt>.V</tt></td><td>DC voltage at node <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.I</tt></td><td>DC current through component <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.v</tt></td><td>AC voltage at node <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.i</tt></td><td>AC current through component <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.vn</tt></td><td>AC noise voltage at node <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.in</tt></td><td>AC noise current through component <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.Vt</tt></td><td>transient voltage at node <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.It</tt></td><td>transient current through component <i>name</i></td></tr>
</table>
Note: All voltages and currents are peak values.
<br><br>

<b>Constants</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>j</tt></td><td>imaginary unit ("square root of -1")</td></tr>
<tr><td><tt>pi</tt></td><td>4*arctan(1) = 3.14159...</td></tr>
<tr><td><tt>e</tt></td><td>Euler = 2.71828...</td></tr>
<tr><td><tt>kB</tt></td><td>Boltzmann constant = 1.38065e-23</td></tr>
</table>

<br><a href="#top">back to the top</a><br>

</body>
</html>
