<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<meta name="Author" content="Jens Flucke">
<title>Qucs - Kurze Beschreibung der mathematischen Funktionen</title>
</head>



<body>
<a name="top" id="top"></a>

<center><h3>
- Qucs -<br>
Ziemlich Universeller Schaltungssimulator<br>
</h3>
<h1>
Kurze Beschreibung der mathematischen Funktionen<br><br>
</h1></center>

Die folgenden Operationen und Funktionen k&ouml;nnen in Gleichungen von Qucs
benutzt werden.<br><br>

<table cellspacing=2 cellpadding=2>
<tr><td><tt>+x</tt></td><td>un&auml;r Plus</td></tr>
<tr><td><tt>-x</tt></td><td>un&auml;r Minus</td></tr>
<tr><td><tt>x+y</tt></td><td>Addition</td></tr>
<tr><td><tt>x-y</tt></td><td>Subtraktion</td></tr>
<tr><td><tt>x*y</tt></td><td>Multiplikation</td></tr>
<tr><td><tt>x/y</tt></td><td>Division</td></tr>
<tr><td><tt>x%y</tt></td><td>Modulo-Operation (Nachkommateil einer Division)</td></tr>
<tr><td><tt>x^y</tt></td><td>Potenz</td></tr>
<tr><td><tt>max(x[,range])</tt></td><td>Maximaler Wert in einem Vektor x; wenn ein Bereich <tt>range</tt> angegeben wird, dann muss <tt>x</tt> eine einfache Datenabh&auml;ngigkeit aufweisen</td></tr>
<tr><td><tt>max(x,y)</tt></td><td>Liefert den gr&ouml;&szlig;eren der beiden Werte <tt>x</tt> und <tt>y</tt></td></tr>
<tr><td><tt>min(x[,range])</tt></td><td>Minimaler Wert in einem Vektor x; wenn ein Bereich <tt>range</tt> angegeben wird, dann muss <tt>x</tt> eine einfache Datenabh&auml;ngigkeit aufweisen</td></tr>
<tr><td><tt>min(x,y)</tt></td><td>Liefert den kleineren der beiden Werte <tt>x</tt> und <tt>y</tt></td></tr>
<tr><td><tt>avg(x[,range])</tt></td><td>Arithmetischer Mittelwert aus den Werten in einem Vektor; wenn ein Bereich <tt>range</tt> angegeben wird, dann muss <tt>x</tt> eine einfache Datenabh&auml;ngigkeit aufweisen</td></tr>
<tr><td><tt>cumavg(x)</tt></td><td>kumulativer Mittelwert der Werte eines Vektors</td></tr>
<tr><td><tt>runavg(x)</tt></td><td>gleitender Mittelwert der Werte eines Vektors</td></tr>
<tr><td><tt>stddev(x)</tt></td><td>Standardabweichung der Werte eines Vektors</td></tr>
<tr><td><tt>variance(x)</tt></td><td>Varianz der Werte eines Vektors</td></tr>
<tr><td><tt>rms(x)</tt></td><td>Effektivwert der Werte eines Vektors</td></tr>
<tr><td><tt>sum(x)</tt></td><td>Summe der Werte in einem Vektor</td></tr>
<tr><td><tt>prod(x)</tt></td><td>Produkt der Werte in einem Vektor</td></tr>
<tr><td><tt>cumsum(x)</tt></td><td>kumulative Summe der Werte in einem Vektor</td></tr>
<tr><td><tt>cumprod(x)</tt></td><td>kumulatives Produkt der Werte in einem Vektor</td></tr>
<tr><td><tt>diff(y,x)</tt></td>
<td>Differenziert den Vektor y in Bezug auf x</td></tr>
<tr><td><tt>diff(y,x,n)</tt></td>
<td>Differenziert den Vektor y in Bezug auf x n-fach</td></tr>
<tr><td><tt>integrate(x,h)</tt></td><td>integriert den Vektor <tt>x</tt> numerisch bei angenommener konstanter Schrittweite <tt>h</tt></td></tr>
<tr><td><tt>real(x)</tt></td><td>Realteil einer komplexen Zahl</td></tr>
<tr><td><tt>imag(x)</tt></td><td>Imagin&auml;rteil einer komplexen Zahl</td></tr>
<tr><td><tt>abs(x)</tt></td><td>absoluter Wert, Betrag einer komplexen Zahl</td></tr>
<tr><td><tt>mag(x)</tt></td><td>gleicher Ausdruck wie abs(x)</td></tr>
<tr><td><tt>polar(m,p)</tt></td><td>liefert komplexe Zahl mit gegebenem Betrag und Phase</td></tr>
<tr><td><tt>norm(x)</tt></td><td>Quadrat von mag(x)</td></tr>
<tr><td><tt>conj(x)</tt></td><td>Konjungiert komplexe Werte der Zahl x</td></tr>
<tr><td><tt>phase(x)</tt></td><td>Phase in Grad</td></tr>
<tr><td><tt>angle(x)</tt></td><td>Phase im Bogenma&szlig;</td></tr>
<tr><td><tt>arg(x)</tt></td><td>gleicher Ausdruck wie angle(x)</td></tr>
<tr><td><tt>deg2rad(x)</tt></td><td>Umrechnung von Grad nach Bogenma&szlig;</td></tr>
<tr><td><tt>rad2deg(x)</tt></td><td>Umrechnung von Bogenma&szlig; nach Grad</td></tr>
<tr><td><tt>unwrap(rad[,tol])</tt></td><td>gleicht Phasenspr&uuml;nge (im Bogenma&szlig;) aus und verwendet dabei die optionale Toleranzschwelle (Standardwert ist pi)</td></tr>
<tr><td><tt>dB(x)</tt></td><td>Spannungsdezibel</td></tr>
<tr><td><tt>dbm(x)</tt></td><td>Wandelt Spannung in Leistung in dBm um</td></tr>
<tr><td><tt>dbm2w(x)</tt></td><td>Wandelt Leistung in dBm in Leistung in Watt um</td></tr>
<tr><td><tt>w2dbm(x)</tt></td><td>Wandelt Leistung in Watt in Leistung in dBm um</td></tr>

<tr><td><tt>sqr(x)</tt></td><td>Quadrat (x zur Potenz zwei)</td></tr>
<tr><td><tt>sqrt(x)</tt></td><td>Quadratwurzel</td></tr>
<tr><td><tt>exp(x)</tt></td><td>Exponentialfunktion zur Basis e</td></tr>
<tr><td><tt>ln(x)</tt></td><td>Nat&uuml;rlicher Logarithmus</td></tr>
<tr><td><tt>log10(x)</tt></td><td>Dekadischer Logarithmus</td></tr>
<tr><td><tt>log2(x)</tt></td><td>Bin&auml;rer Logarithmus</td></tr>
<tr><td><tt>sin(x)</tt></td><td>Sinus von x</td></tr>
<tr><td><tt>cos(x)</tt></td><td>Kosinus von x</td></tr>
<tr><td><tt>tan(x)</tt></td><td>Tangens von x</td></tr>
<tr><td><tt>sinh(x)</tt></td><td>Sinushyperbolikus von x</td></tr>
<tr><td><tt>cosh(x)</tt></td><td>Kosinushyperbolikus von x</td></tr>
<tr><td><tt>tanh(x)</tt></td><td>Tangenshyperbolikus von x</td></tr>
<tr><td><tt>arcsin(x)</tt></td><td>Arkussinus von x</td></tr>
<tr><td><tt>arccos(x)</tt></td><td>Arkuskosinus von x</td></tr>
<tr><td><tt>arctan(x[,y])</tt></td><td>Arkustangens von x</td></tr>
<tr><td><tt>arccot(x)</tt></td><td>Arkuskotangens von x</td></tr>
<tr><td><tt>arsinh(x)</tt></td><td>Area Sinushyperbolikus von x</td></tr>
<tr><td><tt>arcosh(x)</tt></td><td>Area Kosinushyperbolikus von x</td></tr>
<tr><td><tt>artanh(x)</tt></td><td>Area Tangenshyperbolikus von x</td></tr>
<tr><td><tt>arcoth(x)</tt></td><td>Area Kotangenshyperbolikus von x</td></tr>
<tr><td><tt>sec(x)</tt></td><td>Sekans von x</td></tr>
<tr><td><tt>cosec(x)</tt></td><td>Kosekans von x</td></tr>
<tr><td><tt>cot(x)</tt></td><td>Kotangens von x</td></tr>
<tr><td><tt>sech(x)</tt></td><td>Sekanshyperbolikus von x</td></tr>
<tr><td><tt>cosech(x)</tt></td><td>Kosekanshyperbolikus von x</td></tr>
<tr><td><tt>coth(x)</tt></td><td>Kotangenshyperbolikus von x</td></tr>
<tr><td><tt>ztor(x[,zref])</tt></td>
<td>Konvertiert eine Impedanz in einen Reflexionsfaktor (Referenzimpedanz ist standardm&auml;&szlig;ig 50 Ohm)</td></tr>
<tr><td><tt>rtoz(x[,zref])</tt></td>
<td>Konvertiert einen Reflexionsfaktor (Referenzimpedanz ist standardm&auml;&szlig;ig 50 Ohm) in eine Impedanz</td></tr>
<tr><td><tt>ytor(x[,zref])</tt></td>
<td>Konvertiert eine Admittanz in einen Reflexionsfaktor (Referenzimpedanz ist standardm&auml;&szlig;ig 50 Ohm)</td></tr>
<tr><td><tt>rtoy(x[,zref])</tt></td>
<td>Konvertiert einen Reflexionsfaktor (Referenzimpedanz ist standardm&auml;&szlig;ig 50 Ohm) in eine Admittanz</td></tr>
<tr><td><tt>rtoswr(x)</tt></td>
<td>Konvertiert einen Reflexionsfaktor in das (Spannungs-)Stehwellenverh&auml;ltnis</td></tr>
<tr><td><tt>stos(s,zref[,z0])</tt></td>
<td>Konvertiert die S-Parameter-Matrix in eine S-Parameter-Matrix mit unterschiedliche(r/n) Referenzimpedanz(en)</td></tr>
<tr><td><tt>stoy(s[,zref])</tt></td>
<td>Konvertiert die S-Parameter-Matrix in die Y-Parameter-Matrix</td></tr>
<tr><td><tt>stoz(s[,zref])</tt></td>
<td>Konvertiert die S-Parameter-Matrix in die Z-Parameter-Matrix</td></tr>
<tr><td><tt>ytos(y[,z0])</tt></td>
<td>Konvertiert die Y-Parameter-Matrix in die S-Parameter-Matrix</td></tr>
<tr><td><tt>ytoz(y)</tt></td>
<td>Konvertiert die Y-Parameter-Matrix in die Z-Parameter-Matrix</td></tr>
<tr><td><tt>ztos(z[,z0])</tt></td>
<td>Konvertiert die Z-Parameter-Matrix in die S-Parameter-Matrix</td></tr>
<tr><td><tt>ztoy(z)</tt></td>
<td>Konvertiert die Z-Parameter-Matrix in die Y-Parameter-Matrix</td></tr>
<tr><td><tt>twoport(m,von,nach)</tt></td>
<td>Konvertiert eine gegebene 2-Port-Matrix von einer Darstellungsform in eine andere,
m&ouml;gliche Werte f&uuml;r <tt>von</tt> und <tt>nach</tt> sind "Y", "Z", "H", "G",
"A", "S" und "T".</td></tr>
<tr><td><tt>ceil(x)</tt></td><td>Rundet zur n&auml;chstgr&ouml;&szlig;eren Ganzzahl</td></tr>
<tr><td><tt>fix(x)</tt></td><td>Schneidet Nachkommastellen von reellen Zahlen ab</td></tr>
<tr><td><tt>floor(x)</tt></td><td>Rundet zur n&auml;chstkleineren Ganzzahl</td></tr>
<tr><td><tt>round(x)</tt></td><td>Rundet zur n&auml;chsten Ganzzahl</td></tr>

<tr><td><tt>sign(x)</tt></td><td>Berechnet die Signumfunktion</td></tr>
<tr><td><tt>sinc(x)</tt></td><td>Berechnet sin(x)/x und 1 bei x=0</td></tr>
<tr><td><tt>step(x)</tt></td><td>Berechnet die Sprungfunktion</td></tr>
<tr><td><tt>besseli0(x)</tt></td><td>Modifizierte Besselfunktion 0-ter Ordnung</td></tr>
<tr><td><tt>besselj(n,x)</tt></td><td>Besselfunktion erster Art und n-ter Ordnung</td></tr>
<tr><td><tt>bessely(n,x)</tt></td><td>Besselfunktion zweiter Art und n-ter Ordnung</td></tr>
<tr><td><tt>erf(x)</tt></td><td>Fehlerfunktion</td></tr>
<tr><td><tt>erfc(x)</tt></td><td>komplement&auml;re Fehlerfunktion</td></tr>
<tr><td><tt>erfinv(x)</tt></td><td>inverse Fehlerfunktion</td></tr>
<tr><td><tt>erfcinv(x)</tt></td><td>inverse komplement&auml;re Fehlerfunktion</td></tr>
<tr><td><tt>det(x)</tt></td><td>Determinante von x</td></tr>
<tr><td><tt>transpose(x)</tt></td><td>Transponierte Matrix x (Zeilen und Spalten vertauscht)</td></tr>
<tr><td><tt>inverse(x)</tt></td><td>Inverse Matrix von x</td></tr>
<tr><td><tt>eye(n)</tt></td><td>n x n Einheits-Matrix</td></tr>
<tr><td><tt>adjoint(x)</tt></td><td>Transponierte und konjungiert komplexe Matrix x</td></tr>
<tr><td><tt>Rollet(x)</tt></td><td>Rollet Stabilit&auml;tsfaktor der Matrix x (Zweiport S-Parameter Matrix)</td></tr>
<tr><td><tt>Mu(x)</tt></td><td>Mu Stabilit&auml;tsfaktor der Matrix x (Zweiport S-Parameter Matrix)</td></tr>
<tr><td><tt>Mu2(x)</tt></td><td>Mu' Stabilit&auml;tsfaktor der Matrix x (Zweiport S-Parameter Matrix)</td></tr>
<tr><td><tt>linspace(von,bis,n)</tt></td><td>Erzeugt einen Vektor mit <tt>n</tt> linear gleichverteilten Werten zwischen <tt>von</tt> und <tt>bis</tt>, beide Werte mit eingeschlossen</td></tr>
<tr><td><tt>logspace(von,bis,n)</tt></td><td>Erzeugt einen Vektor mit <tt>n</tt> logarithmisch gleichverteilten Werten zwischen <tt>von</tt> und <tt>bis</tt>, beide Werte mit eingeschlossen</td></tr>
<tr><td><tt>NoiseCircle(Sopt,<br>&nbsp;&nbsp;Fmin,Rn,F[,Winkel])</tt></td><td>Kreise mit konstanten Rauschzahlen <tt>F</tt> (kann eine Konstante oder ein Vektor sein), <tt>Winkel</tt> spezifiziert die Winkel in Grad, die z.B. mit <tt>linspace(0,360,100)</tt> erzeugt wurden, wenn <tt>Winkel</tt> eine Zahl ist, dann steht diese f&uuml;r die Anzahl der gleichverteilten Kreissegmente, wenn der Parameter weggelassen wurde, dann wird ein vern&uuml;nftiger Standardwert eingesetzt</td></tr>
<tr><td><tt>StabCircleS(S[,Winkel])</tt></td><td>Stabilit&auml;tskreise in der Quellebene</td></tr>
<tr><td><tt>StabCircleL(S[,Winkel])</tt></td><td>Stabilit&auml;tskreise in der Lastebene</td></tr>
<tr><td><tt>GaCircle(S,Ga[,Winkel])</tt></td><td>Kreis(e) mit konstanter verf&uuml;gbarer Leistungsverst&auml;rkung <tt>Ga</tt> in der Quellebene</td></tr>
<tr><td><tt>GpCircle(S,Gp[,Winkel])</tt></td><td>Kreis(e) mit konstanter Leistungsverst&auml;rkung <tt>Gp</tt> in der Lastebene</td></tr>
<tr><td><tt>PlotVs(data,dep)</tt></td><td>Liefert Daten zur&uuml;ck, die auf <tt>data</tt> basieren (Vektor oder Matrizenvektor) mit der Abh&auml;ngigkeit von dem gegebenen <tt>dep</tt> Vektor, also z.B. <tt>PlotVs(Gain,frequency/1e9)</tt></td></tr>
<tr><td><tt>interpolate(f,x[,n])</tt></td><td>Berechnet eine Interpolation der reellen Funktion <tt>f(x)</tt>an <tt>n</tt> &auml;quidistanten Punkten, letzterer Parameter kann weggelassen werden und erh&auml;lt dann einen vern&uuml;nftigen Standardwert</td></tr>
<tr><td><tt>fft(x)</tt></td><td>Berechnet die schnelle Fourier-Transformation (FFT) des Vektors <tt>x</tt></td></tr>
<tr><td><tt>ifft(x)</tt></td><td>Berechnet die inverse schnelle Fourier-Transformation (IFFT) des Vektors <tt>x</tt></td></tr>
<tr><td><tt>dft(x)</tt></td><td>Berechnet die diskrete Fourier-Transformation (DFT) des Vektors <tt>x</tt></td></tr>
<tr><td><tt>idft(x)</tt></td><td>Berechnet die inverse diskrete Fourier-Transformation (IDFT) des Vektors <tt>x</tt></td></tr>
<tr><td><tt>Time2Freq(v,t)</tt></td><td>Berechnet die diskrete Fourier-Transformation der Funktion <tt>v(t)</tt> und interpretiert die Werte physikalisch</td></tr>
<tr><td><tt>Freq2Time(V,f)</tt></td><td>Berechnet die inverse diskrete Fourier-Transformation der Funktion <tt>V(f)</tt> und interpretiert die Werte physikalisch</td></tr>
<tr><td><tt>kbd(x [,n])</tt></td><td>Kaiser-Bessel Fensterfunktion</td></tr>
<tr><td><tt>yvalue(f,xval)</tt></td><td>Liefert den Y-Wert des gegebenen Vektors <tt>f</tt>, der dem X-Wert <tt>xval</tt> am n&auml;chsten liegt; daf&uuml;r muss der Vektor <tt>f</tt> eine einfache Datenabh&auml;ngigkeit besitzen</td></tr>
<tr><td><tt>xvalue(f,yval)</tt></td><td>Liefert den X-Wert, der mit dem n&auml;chstliegenden Y-Wert zu <tt>yval</tt> aus dem Vektor <tt>f</tt> assoziiert ist; daf&uuml;r muss der Vektor <tt>f</tt> eine einfache Datenabh&auml;ngigkeit besitzen</td></tr>

</table>
<br>

<b>Intervall Schreibweise</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>LO:HI</tt></td><td>Intervall von <tt>LO</tt> bis <tt>HI</tt></td></tr>
<tr><td><tt>:HI</tt></td><td>bis zu <tt>HI</tt></td></tr>
<tr><td><tt>LO:</tt></td><td>von <tt>LO</tt> an</td></tr>
<tr><td><tt>:</tt></td><td>keine Intervallgrenzen</td></tr>
</table>
<br>

<b>Matrix Schreibweise</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>M</tt></td><td>Die gesamte Matrix M</td></tr>
<tr><td><tt>M[2,3]</tt></td><td>Element in der 2. Zeile und der 3. Spalte der Matrix M</td></tr>
<tr><td><tt>M[:,3]</tt></td><td>Vektor bestehend aus der 3. Spalte der Matrix M</td></tr>
</table>
<br>

<b>Wertenamen</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>S[1,1]</tt></td><td>S-Parameter Wert</td></tr>
<tr><td><i>nodename</i><tt>.V</tt></td><td>DC-Spannung am Knoten <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.I</tt></td><td>DC-Strom durch die Komponente <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.v</tt></td><td>AC-Spannung am Knoten <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.i</tt></td><td>AC-Strom durch die Komponente <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.vn</tt></td><td>AC-Rauschspannung am Knoten <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.in</tt></td><td>AC-Rauschstrom durch die Komponente <i>name</i></td></tr>
<tr><td><i>nodename</i><tt>.Vt</tt></td><td>Transientenspannung am Knoten <i>nodename</i></td></tr>
<tr><td><i>name</i><tt>.It</tt></td><td>Transientenstrom durch die Komponente <i>name</i></td></tr>
</table>
Bitte beachten: Alle Spannungen und Str&ouml;me sind Spitzenwerte.
<br><br>

<b>Konstanten</b>
<table cellspacing=2 cellpadding=2>
<tr><td><tt>j</tt></td><td>imagin&auml;re Einheit ("Quadratwurzel von -1")</td></tr>
<tr><td><tt>pi</tt></td><td>4*atan(1) = 3.14159</td></tr>
<tr><td><tt>e</tt></td><td>Eulerzahl = 2.71828</td></tr>
<tr><td><tt>kB</tt></td><td>Boltzmann-Konstante = 1.38065e-23</td></tr>
</table>

<br><a href="#top">zur&uuml;ck nach oben</a><br>

</body>
</html>
